% !TeX root = swp-abgabe3-modulsicht.tex
\documentclass[fontsize=12pt,paper=A4,twoside]{scrartcl}

\input{swp-preamble.tex}
\usepackage[shortlabels]{enumitem}
\usepackage{../tikz-uml}
%\graphicspath{{./images/}}


% Document start
\begin{document}
    \renewcommand\documentTitle{Modulsicht}
    \renewcommand\groupName{KarteikartenAG}

    \newcommand\cat[1]{
    \textbf{\large #1}\\[0.5em]}
    \newcommand\cata[1]{
    \textbf{#1}\\[0.3em]}

    \swpdocument{Rodrigue Wete Nguempnang}{04. Dezember 2022}%
                {Mert As & meras@uni-bremen.de}%
                {Tom Beuke & tombeuke@uni-bremen.de}%
                {Efe Carkcioglu & efe1@uni-bremen.de}%
                {Nadja Cordes & ncordes@uni-bremen.de}%
                {Ole-Niklas Mahlstädt & olma@uni-bremen.de}%
                {Henry Zöllner & henry5@uni-bremen.de}%

    \sffamily
    \KOMAoptions{paper=A4,paper=portrait,pagesize}
    \section{Modulsicht Beschreibung}\label{sec:detailliert:Modulsicht}

    \cat{Module}
    Unsere Module sind in fünf unterschiedliche Module mit teils Untermodulen aufgeteilt.
    \begin{itemize}
        \item \textbf{GUI} mit den Untermodulen: CardGUI, DeckGUI und CategoryGUI mit jeweils mehreren Klassen.
        \item \textbf{Controller} mit den Klassen: CardController, DeckController, CategoryController.
        \item \textbf{Logic} mit den Klassen. CardLogic, DeckLogic, CategoryLogic.
        \item \textbf{Persistence} mit den Klassen CardRepository, DeckRepository, CategoryRepository.
        \item \textbf{Datenmodell}
    \end{itemize}


    \cat{GUI}
    Die \texttt{GUI} ist zuständig für die Darstellung unseres Karteikartensystems.
    Sie ist aufteilt in mehrere Untermodule für die einzelnen Hauptbestandteile
    unserer Software: Die Karteikarten, die Decks zum Lernen der Karteikarten und die Kategorien,
    denen die Karten zugeordnet werden. Diese Module enthalten die einzelnen Klassen zur Darstellung
    unseres Systems.\\\\
    \cata{CardGUI} \texttt{CardGUI} beinhaltet 4 Klassen. In der \texttt{CardOverviewPage} werden
    alle Karten dargestellt (Glossar). Wenn man neue Karten anlegen oder bestehende bearbeiten will, tut
    man dies über die \texttt{EditCardPage}, die über das Glossar geöffnet werden kann. Auch eine Einzelkartensicht
    kann über das Glossar aufgerufen, der User wird dann zur \texttt{ViewSingleCardPage} weitergeleitet.
    Die letzte Seite wird beim Lernmodus genutzt die \texttt{TestCardPage}.\\\\
    \cata{DeckGUI} \texttt{DeckGUI} beinhaltet 3 Klassen. Die Standardseite ist \texttt{DeckOverviewPage},
    in der alle zur Verfügung stehenden Decks aufgelistet werden. Über diese kann auf die \texttt{EditDeckPage}
    navigiert werden, worüber neue Decks erstellt werden oder aber bestehende angepasst werden. Auch kann sich ein
    User ein einzelnes Deck über \texttt{ViewSingleDeckPage} anzeigen lassen mitsamt der wichtigsten Informationen
    zum Deck.\\\\
    \cata{CategoryGUI} \texttt{CategoryGUI} beinhaltet 4 Klassen. \texttt{CategoryOverviewPage} listet alle Kategorien
    und wie oft sie verwendet werden auf. Über die Klasse \texttt{ViewCategoryHierarchyPage} kann
    der Nutzer die gesamte Hierachie der Klassen mit \texttt{Parents} und \texttt{Children} einsehen.
    Auch hier gibt es analog zu \texttt{Deck} und \texttt{Card} eine extra Seite für das Erstellen und Bearbeiten
    (\texttt{EditCategoryPage}) sowie eine Einzelkategorieübersicht (\texttt{ViewSingeCategoryPage}).

    \cat{Controller}
    Der \texttt{Controller} steht im Austausch (TODO) mit der \texttt{GUI} und gibt Aufrufe, die vom Nutzer
    in der \texttt{GUI} gemacht werden, an die \texttt{Logik} weiter.\\
    Er teilt sind in 3 Klassen: \texttt{CardController}, \texttt{DeckController} und \texttt{CategoryController}, die alle Aufrufe, die von den 3 Gui-Untermodulen kommen, bearbeiten.

    \cat{Logik}
    Der \texttt{Logik} ist das Modul, dass sich um die Ausführung von den Anwendungsfällen kümmert.
    Sie leitet Datenbezogene Aufgaben an die \texttt{Persistence} weiter.\\\\
    Die Logik teilt sind in 3 Klassen: \texttt{CardLogic}, \texttt{DeckLogic} und \texttt{CategoryLogic}. Diese übernehmen
    die Ausführung für die einzelnen Submodule.

    \cat{Persistence}
    Der \texttt{Persistence} ist das Modul, dass datenbezogene Arbeiten ausführt. Das Laden und Speichern wird
    an unseren Server weitergegeben.\\\\
    Die Persistence teilt sind in 3 Klassen: \texttt{CardRepository}, \texttt{DeckRepository} und \texttt{CategoryRepository}, die das Laden und Speichern der
    Submodule ausführen, indem sie mit der Datenbank auf dem Server kommunizieren.


    \textbf{TODO}\\
    Klärung Connection Controller / GUI -> aktuell eher einseitig
    \begin{itemize}
    \item Wollen wir über den Controller Fehlermeldungen für die GUI
    aufrufen lassen?
    \item Soll über den Controller das Starten der Applikation + PageManager Geschichten laufen?
    \end{itemize}

    \section{Modulsicht Detailbeschreibung}
    Da die Methoden aufeinander aufbauen, wird hier jeweils die gedachte Funktionsweise von GUI bis Persistence beschrieben.\\\\
    \cat{Karte}
    \begin{itemize}
    \item \textit{N1 Karteikarte anlegen/\\ N3 Karteikarte bearbeiten}\\
    Das Anlegen / Bearbeiter einer Karte wird in \texttt{EditCardPage} mittels \texttt{applyChanges} umgesetzt.
    Dieses ruft im \texttt{CardController} die Methode \texttt{editCard} auf. In der darauf aufgerufenen Methode
    \texttt{updateCardData} mitsamt Weitergabe alter und neuer Karteninformationen erfolgt die Umsetzung in \texttt{CardLogic}.
    Die Logik prüft, ob die Karte neu ist oder geupdatet wird und ruft darauf aufbauend entweder \texttt{saveCard} oder \texttt{updateCard}
    in \texttt{CardRepository} auf.\\
    Auch Tags und Kategorien können über die Seite aufgerufen werden, auch dies wird über die Logik in \texttt{updateCardData} registriert und über die Methoden
    \texttt{createCardToCategory} und \texttt{createTagToCategory} umgesetzt.\\
    Der Nutzer kann zudem die Karte bewerten, was als Attribut in der Karte über \texttt{applyChanges} gespeichert wird.\\
    Zudem werden die Suchwörter bei Aufruf der Methode aktualisiert bzw. eingetragen.
    \item TODO: importieren fehlt\\
    \item \textit{N2 Karteikarte löschen/\\ N23 Kartenauswahl löschen}\\
    Kann entweder bei Kartenbearbeitung (\texttt{CardEditPage}) oder über das Glossar (\texttt{CardOverviewPage})
    für einzelne oder mehrere Karten aufgerufen werden.
    \item \textit{N4 Karteikarte als PDF exportieren/\\ N7 Karteikarte als JSON exportieren /\\Karteikarte als XML exportieren /\\ N24 Kartenauswahl exportieren}\\ Für das Exportieren gibt es eine separate Seite \texttt{ExportSettingsPage}, die nach Aufruf
    in \texttt{CardOverviewPage} aufgerufen wird. Die Methode ist im Abschnitt \texttt{Settings} erläutert.
    \item \textit{N19 Karteikarten anzeigen}\\ Für das Anzeigen der Karteikarten gibt es in \texttt{CardOverviewPage} zwei zugehörige Methoden
    \texttt{getCardsToShowInitially}, nicht alle Karten werden bei Öffnen
    des Glossars angezeigt, die Methode dient dem initialen Laden. Die zweite Methode baut darauf auf und zieht aus \texttt{CardToDeck} die Anzahl der
    Decks pro geladener Karte. \\
    TODO: was ist bei Seitenwechsel im Glossar? zusammenführen des getCountOfDecks nur in Logic aufrufen?
    \item \textit{N20 Karteikartenansicht verändern\\- Filterung}\\
    Für die Filterung der Karte gibt es \texttt{CardOverviewPage} drei Methoden:
    \texttt{showCardsWithCategory}, \texttt{showCardsWithTag}, \texttt{showCardsWithSearchWords}. Diese rufen die zugehörigen \texttt{CardController} Methoden auf. Die an
    die \texttt{CardLogic} übergebenen Methoden werden an den Server über die \texttt{CardRepository} weiterrgeben. \texttt{SearchWords} werden über
    den Server mit den \texttt{getContent} Methoden der \texttt{Card} verglichen.
    \end{itemize}
    \cat{Deck}
    \begin{itemize}
    \item\textit{N25 Karteikasten einzelne Kategorie / \\
    N26 Karteikasten mehrere Kategorien erstellen\\
    N27 Karteikasten bearbeiten\\
    N28 Lernsystem auswählen}\\
    Analog wie bei \texttt{Card} gibt es eine gebündelte Methode für die Bearbeitung und Erstellung von Karteikästen.
    Sollte der Nutzer später sein Lernsystem ändern, wird dies auch über die Methode aufgerufen in der \texttt{GUI} aber später in der \texttt{DeckLogic}
    separat behandelt über \texttt{updateStudySystem}.
    \item \texttt{N28-4 Neue Lernmethoden erstellen} TODO
    \item \texttt{N31 Kasten Lernen/ \\N32 Lernvorgang unterbrechen/ \\N33 Lernvorgang fortsetzen/ \\N34 Lernfortschritt/ \\N35 Antwort prüfen} TODO
    \item \texttt{N35 Status der Karteikarten/ \\ N36 Karteikastenübersicht}\\
    Für die Karteikästen gibt es, wie bei Karteikarten auch, eine Übersicht, wo zu jedem Karteikasten seine Karten und ihr Status angezeigt werden.
    Dies wird über die Methode \texttt{showDecks} in \texttt{DeckOverviewPage} realisiert. Hier wird die Methode \texttt{getCardToDecks} im \texttt{DeckController},
    die in der \texttt{DeckLogic} bearbeitet wird und weiter aufgesplittet. Zunächst wird dort \texttt{getDecksAndCards} aufgerufen, in der dann Zunächst
    die Decks mittel \texttt{getDecks} alle Decks gezogen werden und dann für jedes Deck mit \texttt{getCardsToDeck} die einzelnen Karten mit Status
    ermittelt werden.
    \item Karteikasten löschen: Wird über \texttt{DeckOverviewPage} aufgerufen, für einen oder mehrere Karteikästen.
    \end{itemize}
    \cat{Category}
    \begin{itemize}
        \item \textit{N12 Kategorie anlegen/ \\ N14 Kategorie bearbeiten} TODO gleich wie Card und Deck machen, aktuell separate Methoden in GUI?
    Analog wie bei Karteikarten und Karteikästen gibt eine Methode für das Bearbeiten und Erstellen von Kategorien. (Hierarchieanpassungen beschreiben)
        \item \textit{N14 Kategorie löschen}\\
    Eine Kategorie kann über \texttt{EditCategoryPage} gelöscht werden.
    \item \textit{N15 Kategorien anzeigen} TODO: Sollen die Karten in der Übersicht mit angezeigt werden? Über getCategories in Logic mitreinnehmen?\\
    \end{itemize}
    \cat{Settings}
    TODO: Export beschreiben, mehr?
    
    



   
     \newpage
    \recalctypearea

    %Only to show how the structure is
    %some methods are still missing, folder implementation has more detail
    \KOMAoptions{paper=A3,paper=landscape,pagesize}
    \thispagestyle{empty}
    \begin{tikzpicture}%
        \input{module/ModuleOverview.tex}
    \end{tikzpicture}
    \newpage
    %Only to show how the structure is
    %some methods are still missing, folder implementation has more detail
    \KOMAoptions{paper=A2,paper=landscape,pagesize}
    \thispagestyle{empty}
    \begin{tikzpicture}%
        \input{module/Modules.tex}
    \end{tikzpicture}
    \newpage


    \newcommand\user{Susi}
    \newcommand\editpage{e}
    \newcommand\testpage{t}
    \newcommand\deckpage{d}
    \newcommand\ssystem{s}
    \newcommand\control{c}
    \newcommand\logic{l}
    \newcommand\pers{p}
    \thispagestyle{empty}
    \begin{minipage}{0cm}
        \input{sequenzdiagramm/createcard.tex}
    \end{minipage}
    \hspace*{1.6\textwidth}
    \begin{minipage}{50cm}
        \input{sequenzdiagramm/testcard.tex}
    \end{minipage}
    \recalctypearea
\end{document}

%\begin{umlfragment}
%    \begin{umlcall}[op=opb(), type=synchron, return=1]{b}{c}
%        \begin{umlfragment}[type=alt, label=condition, inner xsep=8, fill=green!10]
%            \begin{umlcall}[op=opc(), type=asynchron, fill=red!10]{c}{d}
%            \end{umlcall}
%            \begin{umlcall}[type=return]{c}{b}
%            \end{umlcall}
%            \umlfpart[default]
%            \begin{umlcall}[op=opd(), type=synchron, return=3]{c}{d}
%            \end{umlcall}
%        \end{umlfragment}
%    \end{umlcall}
%\end{umlfragment}
%\begin{umlfragment}
%    \begin{umlcallself}[op=ope(), type=synchron, return=4]{b}
%        \begin{umlfragment}[type=assert]
%            \begin{umlcall}[op=opf(), type=synchron, return=5]{b}{c}
%            \end{umlcall}
%        \end{umlfragment}
%    \end{umlcallself}
%\end{umlfragment}

%\begin{umlfragment}
%    \begin{umlcall}[op=opg(), name=test, type=synchron, return=6, dt=7, fill=red!10]{\user}{e}
%        \umlcreatecall[class=F, stereo=boundary, x=12]{e}{f}
%    \end{umlcall}
%    \begin{umlcall}[op=oph(), type=synchron, return=7]{\user}{e}
%    \end{umlcall}
%\end{umlfragment}